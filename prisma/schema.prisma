// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}


// Z - created models for basic functionality
//


// Z - all ticket quotas applicable for buying 
model ticketReserves {                                  
    id        Int      @id @default(autoincrement())    
    type      buyerGroups[]                            // Z - type of ticket (eg. student, alumni, public, etc...)
    amount    Int                                       // Z - amount of tickets available
    price     Int                                       // Z - price of the ticket
    updatedAt DateTime @updatedAt                       // Z - timestamp of last update - to track backend changes
    updatedBy String                                    // Z - user who updated the entry - to track backend changes
    deliveryMethods deliveryMethods[]
}

// Z - all tickets sold 
model soldTickets {                                    
    id        Int      @id @default(autoincrement())
    delivery  String                                   // Z - delivery method of the ticket
    code      String   @unique                         // Z - code need when using pickup as delivery method (randomly generate?)
    paid      Boolean?
    sent      Boolean?                                // Z - has the ticket been sent? (only relevant if the delivery is not a reservation)
    transref  String                                   // Z - placeholder for a transaction reference from stripe 
    timestamp DateTime @default(now()) 
    buyerId   Int
    buyer     Buyers   @relation(fields: [buyerId], references: [id], onDelete: Cascade)
}

// Z - all available delivery methods
model deliveryMethods {
    id        Int      @id @default(autoincrement())
    name      String
    surcharge Int?
    ticketReserves  ticketReserves[]
}

// Z - database of buyers
model Buyers {
    id        Int      @id @default(autoincrement())
    name      String   
    email     String   @unique
    phone     String
    address   String
    postal    Int                                      // Z - maybe restrict to austrian postal codes
    province  String
    country   String
    verified  Boolean                                  // Z - did the buyer already pass email verification? 
    maxTickets  Int // --> zu groups!
    tickets   soldTickets[]
    groupId   Int
    group     buyerGroups @relation(fields: [groupId], references: [id])
}

// Z - groups for the buyers, to determine which types of tickets are available to buy
model buyerGroups {
    id        Int      @id @default(autoincrement())
    name      String
    buyers    Buyers[]
    ticketReserves ticketReserves[]
}

// Z - users that should later be able to login into the backend
model backendUsers {
    id        Int      @id @default(autoincrement())
    firstName String   
    surName   String   
    email     String   @unique
    passwordHash String
    groupId   Int?
    group     backendGroups? @relation(fields: [groupId], references: [id])
}

model backendGroups {
    id   Int    @id @default(autoincrement())
    name String
    users backendUsers[]
}


model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?
  accounts      Account[]
  sessions      Session[]
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}